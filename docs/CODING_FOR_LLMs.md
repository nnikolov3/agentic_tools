# Coding Standards for LLM-Generated Code

This document provides explicit, actionable coding standards for all code generated by Large Language Models (LLMs) - this includes you! When generating code, you MUST follow these principles and guidelines to ensure the output is simple, robust, maintainable, and professional. These standards represent our collective commitment to code quality and help prevent technical debt, brittle systems, and slowed innovation.

The standards are organized into core design principles that apply to all languages and language-specific guidelines with concrete examples. Follow these standards precisely - they are not suggestions but requirements for all generated code.

## Core Design Principles

These principles apply to all code generation regardless of language. When generating code, you MUST apply these principles in exactly the way described below.

### 1. Simplicity is Non-Negotiable

When solving any problem, strive for the most straightforward solution that fulfills all requirements. Complexity is not a measure of sophistication:

- It is the primary source of bugs, security vulnerabilities, and crippling maintenance overhead
- A complex system is difficult to reason about, making it impossible to modify with confidence
- If a generated design is not simple, it is wrong - re-evaluate the approach

### 2. Methodical Problem Decomposition

Before generating implementation code, methodically decompose problems into independent subproblems:

1. **Identify and Isolate the Core Problem:** Articulate the precise problem to be solved, separating it from surrounding concerns.

2. **Deconstruct into Subproblems:** Break the core problem down into the smallest possible, independent, verifiable subproblems.

3. **Analyze Constraints and Environment:** For each subproblem, consider the limitations and features of the chosen language, framework, and environment. Identify potential edge cases, failure modes, and performance constraints up front.

4. **Solve Incrementally:** Address one single subproblem at a time. Generate code that solves and verifies each piece before integrating it into a larger solution. This prevents complex, monolithic solutions.

### 3. Explicit Over Implicit

All generated intentions, dependencies, and behaviors must be clear and explicit:

- Never rely on "magic" or hidden mechanisms that obscure cause-and-effect relationships
- Make all assumptions visible and auditable in the code itself
- Ambiguity and side effects create unpredictable systems

### 4. Self-Documenting Code and Ultimate Readability

Generated code is read far more often than it is written; therefore, optimize for the reader:

- **Intention-Revealing Names:** Use meticulously chosen, intention-revealing names for variables, functions, and classes. **Variable names must be descriptive and unambiguous; single-letter or cryptic two-letter variables are strictly forbidden.**

- **Purpose of Comments:** Comments must explain the _why_, not the _what_. They should clarify complex logic, business rules, or the reasoning behind a specific implementation choice. If generated code is so complex that it needs comments to explain _what_ it does, the code must be refactored for simplicity.

- **Comment Quality and Hygiene:** Every source file must begin with a comment explaining its purpose and responsibility within the system. Throughout generated code, comments must be clear, concise, and professional.

### 5. Single Responsibility and Low Complexity

Every generated function, class, or module must have one, and only one, reason to change:

- Generated code should do one thing and do it with precision and efficiency
- This principle naturally leads to code that is easier to test, reuse, and refactor
- Keep cognitive and cyclomatic complexity minimal for maintainable components

### 6. Acyclic Dependencies

Generated code must form a Directed Acyclic Graph (DAG) with no circular dependencies:

- Circular dependencies represent a critical architectural flaw
- They create a "big ball of mud" making components impossible to isolate, test, or deploy

### 7. Composition Over Inheritance

When generating code for reuse and behavior extension:

- Always favor composition and interfaces over implementation inheritance
- Deep inheritance hierarchies lead to the "fragile base class" problem
- Changes in parent classes can break descendants in unpredictable ways

### 8. Error Handling Excellence

All generated code must handle errors explicitly and immediately where they occur:

- Never ignore or swallow exceptions
- **All error messages must be explicit, provide clear context about what failed, and avoid ambiguity**
- Generated systems must fail fast and loudly to prevent corrupt state continuation

### 9. Test-Driven Correctness

Tests are a core part of implementation code that you generate:

- All generated components must follow a **test-driven development (TDD)** approach
- Generate failing tests before implementation code
- The test suite is the ultimate proof of correctness
- **Total test coverage must exceed 80% for any project**

### 10. Verifiable Truth and No Deception

All generated claims about functionality require demonstrable, verifiable proof:

- Generate code backed by comprehensive test suites
- Deceptive placeholders or hardcoded return values are strictly forbidden

### 11. Automated Quality Enforcement

Generated code must pass quality tools with zero issues:

- **Extensive use of linters, formatters, and static analysis is mandatory**
- **Suppressing linter warnings with comments is strictly forbidden**
- A linter warning indicates an underlying issue requiring code redesign

### 12. Immutability By Default

When designing generated components:

- Make them immutable whenever possible
- This eliminates bugs related to side effects and unpredictable state changes

### 13. Efficient Memory Management

All generated code must be deliberate about resource usage:

- Avoid unnecessary allocations
- Ensure generated resources are explicitly released

### 14. Consistency Reduces Cognitive Load

Generated code must rigorously follow established style guides:

- Create predictable and easily understood implementations
- Apply the same conventions consistently across all generated code

### 15. No Premature Optimization

When generating code:

- First write correct, clean, and simple code
- Only apply targeted optimizations after identifying measured bottlenecks

### 16. Remove What Isn't Used

Generated code must not include unused elements:

- Delete any dead code, unused variables, or unnecessary abstractions
- Remove stale comments; if a comment no longer accurately describes the code, update or delete it immediately
- Every line you generate is a liability that requires maintenance

### Operational Mandates

#### 1. Pre-Code Validation

Before generating any code:

- **Confirm Necessity**: Verify that the code is absolutely necessary and does not duplicate existing functionality
- **Justify New Code**: Document why existing solutions are insufficient when new code is required

#### 2. Implementation Discipline

When generating code:

- **Declare at the Top**: Instantiate all variables at the top of their respective scope
- **No Magic Numbers**: Use named constants instead of hardcoded values
- **Parameterize Everything**: Strictly decouple application logic from configuration

#### 3. Verification Loop

Apply this development cycle to all generated code:

- **Test, Implement, Lint, Format, Refactor, Repeat**
- All generated code must pass automated quality checks

#### 4. Security as a Default

Generated components must follow strict security practices:

- **Least Privilege**: Components should only have permissions they absolutely need
- **Validate at Boundaries**: Rigorously validate and sanitize all external data
- **Never Log Secrets**: Secrets must never be written to logs or stored in plaintext

## Language-Specific Standards

When generating code in any specific language, you MUST additionally follow the language-specific standards below, which build upon the core principles above.

### Python Coding Standards

When generating Python code, you must follow these standards precisely:

#### 1. Automated Toolchain Requirements (Python)

Generated Python code must pass these tools with zero errors or warnings:

- **Formatter**: `black` for uniform code style
- **Linter**: `ruff` for catching errors and bad practices
- **Type Checker**: `mypy` for static type analysis

#### 2. Type Hints Implementation

Every function and method signature must include explicit type hints for all arguments and the return value:

```python
# ❌ BAD: No type hints - this is unacceptable
def process_data(data, multiplier):
    return data * multiplier

# ✅ GOOD: Complete type hints - this is what you MUST generate
from typing import List

def process_data(data: List[int], multiplier: int) -> List[int]:
    return [item * multiplier for item in data]
```

#### 3. Immutability and Memory Management

For collections that should not change, prefer tuples over lists:

```python
# ❌ BAD: Using list when data should be immutable
def get_config_options() -> list:
    return ["option1", "option2", "option3"]

# ✅ GOOD: Using tuple for immutable data
def get_config_options() -> tuple:
    return ("option1", "option2", "option3")
```

Process large files using generators to avoid memory issues:

```python
# ❌ BAD: Loads entire file into memory
def process_large_file(file_path: str) -> List[str]:
    with open(file_path) as f:
        lines = f.readlines()
    return lines

# ✅ GOOD: Processes file line-by-line using minimal memory
from typing import Generator

def process_large_file_generator(file_path: str) -> Generator[str, None, None]:
    with open(file_path) as f:
        for line in f:
            yield line

# Usage example - note how this pattern should be followed
# for processed_line in process_large_file_generator("huge_log.txt"):
#     process_line(processed_line)
```

#### 4. Error Handling Implementation

Always chain exceptions to preserve the root cause context:

```python
# ❌ BAD: Losing original exception context - NEVER generate this
try:
    value = int(some_string)
except ValueError:
    raise RuntimeError("Invalid configuration value")

# ✅ GOOD: Chaining exceptions to preserve context - ALWAYS generate this
try:
    value = int(some_string)
except ValueError as e:
    raise RuntimeError("Invalid configuration value") from e
```

#### 5. Testing Requirements

When generating Python tests, you must follow these standards:

- Use `pytest` as the testing framework
- Make all tests independent with proper setup and teardown using fixtures
- Use `pytest.raises()` to assert expected exceptions

Example of what you MUST generate for test code:

```python
import pytest

def test_divide_by_zero():
    with pytest.raises(ZeroDivisionError) as exc_info:
        result = 10 / 0
    assert "division by zero" in str(exc_info.value)
```

### Go Coding Standards

When generating Go code, you must follow these standards precisely:

#### 1. Automated Toolchain Requirements (Go)

Generated Go code must pass these tools with zero errors or warnings:

- **Formatter**: `gofmt` or `gofumpt` for standard Go formatting
- **Linter**: `golangci-lint` for comprehensive static analysis

#### 2. Naming Conventions

Follow Go naming conventions precisely:

- Use `camelCase` for unexported identifiers
- Use `PascalCase` for exported identifiers
- Every exported identifier MUST have a `godoc` comment

```go
// ❌ BAD: No godoc comment - this is unacceptable
func ProcessData(data []int, multiplier int) []int {
    // ...
}

// ✅ GOOD: Exported function with proper godoc comment - this is what you MUST generate
// ProcessData multiplies each item in the data slice by the multiplier.
func ProcessData(data []int, multiplier int) []int {
    result := make([]int, len(data))
    for i, item := range data {
        result[i] = item * multiplier
    }
    return result
}
```

#### 3. Complexity Limits Enforcement

Generated Go code must adhere to these strict limits (refactor if exceeded):

- **Function Length**: Maximum **60 lines** or **40 statements**
- **Cyclomatic Complexity**: Maximum **10** per function
- **Cognitive Complexity**: Maximum **5** per function

#### 4. Error Handling Implementation (Go)

Every call that returns an error must use a new, uniquely named error variable:

```go
// ❌ BAD: 'err' is reassigned - NEVER generate this
file, err := os.Open("config.yaml")
if err != nil {
    // ...
}
data, err := io.ReadAll(file) // This re-declaration hides the first error
if err != nil {
    // ...
}

// ✅ GOOD: Each error has a unique variable - ALWAYS generate this
file, openErr := os.Open("config.yaml")
if openErr != nil {
    return fmt.Errorf("failed to open config file: %w", openErr)
}
defer file.Close()

data, readErr := io.ReadAll(file)
if readErr != nil {
    return fmt.Errorf("failed to read config file: %w", readErr)
}
```

#### 5. Concurrency Implementation

Generated Go code with concurrency must:

- Pass a `context.Context` as the first argument for I/O or long-running operations
- Use channels for communication between goroutines ("don't communicate by sharing memory")

```go
// ❌ BAD: No context - NEVER generate this
func FetchUserData(userID string) (*User, error) {
    // ...
}

// ✅ GOOD: Context as first parameter - ALWAYS generate this
func FetchUserData(ctx context.Context, userID string) (*User, error) {
    // ...
}
```

#### 6. Testing Requirements

When generating Go tests, you MUST follow these standards:

- Use the standard `testing` package with `testify/assert` or `testify/require`
- Apply table-driven tests for multiple scenarios

Example of what you MUST generate for Go test code:

```go
func TestAddition(t *testing.T) {
    tests := []struct {
        name     string
        a, b     int
        expected int
    }{
        {"positive numbers", 2, 3, 5},
        {"negative numbers", -1, -1, -2},
        {"zero additions", 0, 5, 5},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := add(tt.a, tt.b)
            assert.Equal(t, tt.expected, result)
        })
    }
}

func add(a, b int) int {
    return a + b
}
```

### Bash Coding Standards

Bash scripts are strictly for simple automation and glue code. When logic becomes complex, you MUST use Go or Python instead. When generating Bash code, you must follow these standards precisely:

#### 1. Automated Toolchain Requirements (Bash)

Generated Bash code must pass `shellcheck` with zero errors or warnings:

- **Linter**: `shellcheck` for static analysis

#### 2. Mandatory Settings

Every generated Bash script MUST begin with strict mode settings:

```bash
# ✅ GOOD: Strict mode settings - this is REQUIRED at the beginning
set -euo pipefail

# set -e: Exit immediately on non-zero exit codes
# set -u: Treat unset variables as an error
# set -o pipefail: Ensure failures in pipelines are caught
```

#### 3. Naming Conventions

Generated Bash code MUST follow these naming conventions:

- Use `readonly UPPER_CASE_SNAKE` for global constants
- Use `local lower_case_snake` for local variables
- Use `lower_case_snake` for functions

```bash
# ❌ BAD: Inconsistent naming - NEVER generate this
MAXRETRIES=3
local tempFile=""
function Process-Data() { # ... }

# ✅ GOOD: Consistent naming conventions - ALWAYS generate this
readonly MAX_RETRIES=3
local temp_file=""
function process_data() { # ... }
```

#### 4. Safety Practices

Generated Bash code MUST always follow these safety practices:

- Quote ALL variables and command substitutions
- Use `printf` instead of `echo` for variables
- Use direct input redirection instead of `cat` pipelines

```bash
# ❌ BAD: Unquoted variables - NEVER generate this
echo $file_name
count=$(wc -l $file_path)
cat "$temp_file" | grep "error"

# ✅ GOOD: Proper quoting and safe practices - ALWAYS generate this
printf '%s\n' "$file_name"
count=$(wc -l "$file_path")
grep "error" < "$temp_file"
```

#### 5. Error Handling Implementation

When generating Bash code, NEVER redirect errors to `/dev/null`:

- Capture all command results explicitly
- Process exit codes properly

```bash
# ❌ BAD: Hiding errors - NEVER generate this
command >/dev/null 2>&1
some_tool --config "$config_file" 2>/dev/null

# ✅ GOOD: Capturing output, errors, and exit codes - ALWAYS generate this
local output
local exit_code
output=$(command 2>&1) || exit_code=$?

if [[ $exit_code -ne 0 ]]; then
    printf '%s\n' "Command failed with output: $output" >&2
    exit 1
fi
```

## For LLM Agents: How To Use This Document Effectively

This document is designed specifically for LLM agents like yourself to generate high-quality code. When using this document as a prompt for code generation:

1. **Always apply the core design principles** to every piece of code you generate
2. **Additionally follow language-specific standards** for the target language
3. **Pay close attention to the examples** - they show what NOT to generate (❌ BAD) and what MUST be generated (✅ GOOD)
4. **Study the patterns in the examples** - these demonstrate the precise formatting and structure you should use
5. **Write self-documenting code** with intention-revealing names
6. **Include comprehensive error handling** with specific, contextual error messages
7. **Generate tests before implementation** when possible
8. **Keep generated components simple** - if a function seems complex, break it down into smaller functions

This approach aligns with the principles from PROMPT_ENGINEERING.md by providing clear context, specific examples, and explicit instructions for what constitutes acceptable vs. unacceptable code patterns.

## Conclusion

These standards ensure all generated code is consistent, maintainable, and high-quality regardless of implementation language. When in doubt, favor simplicity and clarity over cleverness or brevity. Code is primarily meant to be read and understood by humans.
